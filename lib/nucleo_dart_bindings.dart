// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

@ffi.Native<ffi.Pointer<NucleoHandle> Function(VoidCallbackFn)>()
external ffi.Pointer<NucleoHandle> nucleo_dart_new(VoidCallbackFn cb);

@ffi.Native<ffi.Void Function(ffi.Pointer<NucleoHandle>)>()
external void nucleo_dart_destroy(ffi.Pointer<NucleoHandle> ptr);

@ffi.Native<ffi.Void Function(ffi.Pointer<NucleoHandle>, ffi.UnsignedInt)>()
external void nucleo_dart_tick(ffi.Pointer<NucleoHandle> ptr, int ms);

@ffi.Native<ffi.Void Function(ffi.Pointer<NucleoHandle>, NucleoDartStringMut)>()
external void nucleo_dart_add(
  ffi.Pointer<NucleoHandle> ptr,
  NucleoDartStringMut item,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<NucleoHandle>,
    ffi.Pointer<NucleoDartStringMut>,
    ffi.UintPtr,
  )
>()
external void nucleo_dart_add_all(
  ffi.Pointer<NucleoHandle> ptr,
  ffi.Pointer<NucleoDartStringMut> list,
  int len,
);

/// By specifying append the caller promises that text passed to the previous reparse invocation
/// is a prefix of new_text. This enables additional optimizations but can lead to missing matches
/// if an incorrect value is passed.
@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<NucleoHandle>,
    NucleoDartString,
    ffi.UnsignedInt,
  )
>(symbol: 'nucleo_dart_reparse')
external void _nucleo_dart_reparse(
  ffi.Pointer<NucleoHandle> ptr,
  NucleoDartString new_text,
  int append,
);

void nucleo_dart_reparse(
  ffi.Pointer<NucleoHandle> ptr,
  NucleoDartString new_text,
  IsAppend append,
) => _nucleo_dart_reparse(ptr, new_text, append.value);

@ffi.Native<ffi.Pointer<SnapshotHandle> Function(ffi.Pointer<NucleoHandle>)>()
external ffi.Pointer<SnapshotHandle> nucleo_dart_get_snapshot(
  ffi.Pointer<NucleoHandle> ptr,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<SnapshotHandle>)>()
external int nucleo_dart_snapshot_get_item_count(
  ffi.Pointer<SnapshotHandle> handle,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<SnapshotHandle>)>()
external int nucleo_dart_snapshot_get_matched_item_count(
  ffi.Pointer<SnapshotHandle> handle,
);

@ffi.Native<
  NucleoDartString Function(ffi.Pointer<SnapshotHandle>, ffi.Uint32)
>()
external NucleoDartString nucleo_dart_snapshot_get_item(
  ffi.Pointer<SnapshotHandle> handle,
  int index,
);

@ffi.Native<
  NucleoDartString Function(ffi.Pointer<SnapshotHandle>, ffi.Uint32)
>()
external NucleoDartString nucleo_dart_snapshot_get_matched_item(
  ffi.Pointer<SnapshotHandle> handle,
  int index,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<SnapshotHandle>,
    ffi.Uint32,
    ffi.Uint32,
    AppendCallbackFn,
  )
>()
external void nucleo_dart_snapshot_get_matched_items(
  ffi.Pointer<SnapshotHandle> handle,
  int start,
  int end,
  AppendCallbackFn cb,
);

enum IsAppend {
  IsAppendYes(0),
  IsAppendNo(1);

  final int value;
  const IsAppend(this.value);

  static IsAppend fromValue(int value) => switch (value) {
    0 => IsAppendYes,
    1 => IsAppendNo,
    _ => throw ArgumentError('Unknown value for IsAppend: $value'),
  };
}

final class NucleoHandle extends ffi.Opaque {}

final class SnapshotHandle extends ffi.Opaque {}

typedef VoidCallbackFnFunction = ffi.Void Function();
typedef DartVoidCallbackFnFunction = void Function();
typedef VoidCallbackFn =
    ffi.Pointer<ffi.NativeFunction<VoidCallbackFnFunction>>;

final class NucleoDartStringMut extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> ptr;

  @ffi.UintPtr()
  external int len;
}

final class NucleoDartString extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> ptr;

  @ffi.UintPtr()
  external int len;
}

typedef AppendCallbackFnFunction = ffi.Void Function(NucleoDartString);
typedef DartAppendCallbackFnFunction = void Function(NucleoDartString);
typedef AppendCallbackFn =
    ffi.Pointer<ffi.NativeFunction<AppendCallbackFnFunction>>;
